---
layout: post
status: publish
published: true
title: Collecting events into Azure Functions and triggering your custom code using
  fluent-plugin-azurefunctions
author:
  display_name: Yoichi Kawasaki
  login: yoichi
  email: yokawasa@gmail.com
  url: http://github.com/yokawasa
author_login: yoichi
author_email: yokawasa@gmail.com
author_url: http://github.com/yokawasa
wordpress_id: 101
wordpress_url: http://unofficialism.info/posts/?p=101
date: '2016-11-27 08:27:46 +0900'
date_gmt: '2016-11-26 23:27:46 +0900'
categories:
- Azure
- English
tags:
- fluentd
- Ruby
- AzureFunctions
- fluent-plugin-azurefunctions
---
<p>In this article, I&rsquo;d like to introduces a solution to collect events from various sources and send them into HTTP Trigger function in Azure Functions using <a href="https://github.com/yokawasa/fluent-plugin-azurefunctions">fluent-plugin-azurefunctions</a>. Triggers in Azure Functions are event responses used to trigger your custom code. <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-http-webhook">HTTP Trigger functions</a> allow you to respond to HTTP events sent from fluentd and cook them into whatever you want! </p>
<p><center><br />
<img src="https://c6.staticflickr.com/6/5747/31080973501_83e854eb4a_c.jpg" width="800" height="357" alt="fluent-plugin-azurefunctions"><br />
</center></p>
<p>[note] <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-overview">Azure Functions</a> is a ("serverless") solution for easily running small pieces of code, or "functions," in Azure. <a href="http://www.fluentd.org/">Fluentd</a> is an open source data collector, which lets you unify the data collection and consumption for a better use and understanding of data. <a href="https://github.com/yokawasa/fluent-plugin-azurefunctions">fluent-plugin-azurefunctions</a> is a fluentd output plugin that enables to collect events into Azure Functions.</p>
<h2>Pre-requisites</h2>
<ul style="list-style:disc inside">
<li>A basic understanding of fluentd - if you're not familiar with fluentd, <a href="http://docs.fluentd.org/articles/quickstart">fluentd quickstart guide</a> is good starting point</li>
<li>Azure subscription - you need to have Azure subscription that grants you access to Microsoft Azure services, and under which you can create Azure Functions account. If you don't have yet click <a href="https://account.windowsazure.com/Subscriptions">here</a> to create it</li>
</ul>
<h2>Setup: Azure Functions (HTTP Trigger Function) </h2>
<p>Create a function (HTTP Trigger). First, you need to have an function app that hosts the execution of your functions in Azure if you don't already have. Once you have an function app, you can create a function. Here are instructions:</p>
<ul style="list-style:disc inside">
<li><a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-first-azure-function">Create your first Azure Function</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference">Azure Functions developer reference</a></li>
</ul>
<p>A quick-start HTTP trigger function sample is included under <a href="https://github.com/yokawasa/fluent-plugin-azurefunctions/tree/master/examples/function-csharp">examples/function-csharp</a> in Github repository. You simply need to save the code (<a href="https://github.com/yokawasa/fluent-plugin-azurefunctions/blob/master/examples/function-csharp/run.csx">run.csx</a>) and configuration files (<a href="https://github.com/yokawasa/fluent-plugin-azurefunctions/blob/master/examples/function-csharp/function.json">function.json</a>, <a href="https://github.com/yokawasa/fluent-plugin-azurefunctions/blob/master/examples/function-csharp/project.json">project.json</a>) in the same Azure function folder. Explaining a little bit about each of files, the <strong>function.json</strong> file defines the function bindings and other configuration settings. The runtime uses this file to determine the events to monitor and how to pass data into and return data from function execution. The <strong>project.json</strong> defines packages that the application depends. The <strong>run.csx</strong> is a core application file where you write your code to process Your jobs. Here is a sample run.csx:</p>
<p><script src="https://gist.github.com/yokawasa/90b832251e728139cb9a411bd51fd71f.js"></script></p>
<h2>Setup: Fluentd</h2>
<p>First of all, install Fluentd. The following shows how to install Fluentd using Ruby gem packger but if you are not using Ruby Gem for the installation, please refer to <a href="http://docs.fluentd.org/categories/installation">this installation guide</a> where you can find many other ways to install Fluentd on many platforms.</p>
<p><code lang="bash"><br />
# install fluentd<br />
sudo gem install fluentd --no-ri --no-rdoc</p>
<p># create fluent.conf<br />
fluentd --setup <directory-path-to-fluent-conf><br />
</code></p>
<p>Also, install <a href="https://github.com/yokawasa/fluent-plugin-azurefunctions">fluent-plugin-azurefunctions</a> for fluentd aggregator to send collected event data into Azure Functions.<br />
<code lang="bash"><br />
sudo gem install fluent-plugin-azurefunctions<br />
</code></p>
<p>Next, configure fluent.conf, a fluentd configuration file as follows. Please refer to <a href="https://github.com/yokawasa/fluent-plugin-azurefunctions#fluentd---fluentconf">this</a> for fluent-plugin-azurefunctions configuration. The following is a sample configuration where the plugin writes only records that are specified by key_names in incoming event stream out to Azure Functions:</p>
<p><code><br />
# This is used by event forwarding and the fluent-cat command<br />
<source><br />
    @type forward<br />
    @id forward_input<br />
</source></p>
<p># Send Data to Azure Functions<br />
<match azurefunctions.**><br />
    @type azurefunctions<br />
    endpoint  AZURE_FUNCTION_ENDPOINT   # ex. https://<accountname>.azurewebsites.net/api/<functionname><br />
    function_key AZURE_FUNCTION_KEY     # ex. aRVQ7Lj0vzDhY0JBYF8gpxYyEBxLwhO51JSC7X5dZFbTvROs7uNg==<br />
    key_names key1,key2,key3<br />
    add_time_field true<br />
    time_field_name mytime<br />
    time_format %s<br />
    localtime true<br />
    add_tag_field true<br />
    tag_field_name mytag<br />
</match><br />
</code></p>
<p>[note] If <strong>key_names</strong> not specified above, all incoming records are posted to Azure Functions (See also <a href="https://github.com/yokawasa/fluent-plugin-azurefunctions#fluentd---fluentconf">this</a>).</p>
<p>Finally, run fluentd with the fluent.conf that you configure above.</p>
<p><code lang="bash"><br />
fluentd -c ./fluent.conf -vv &<br />
</code></p>
<h2>TEST</h2>
<p>Let's check if test events will be sent to Azure Functions that triggers the HTTP function (let's use <a href="https://github.com/yokawasa/fluent-plugin-azurefunctions/tree/master/examples/function-csharp">the sample function</a> included in Github repo this time). First, generate test events using fluent-cat like this:<br />
<code><br />
echo ' { "key1":"value1", "key2":"value2", "key3":"value3"}' | fluent-cat azurefunctions.msg<br />
</code></p>
<p>As both <strong>add_time_field</strong> and <strong>add_tag_field</strong> are enabled, time and tag fields are added to the record that are selected by <strong>key_names</strong> before posting to Azure Functions, thus actual HTTP Post request body would be like this:</p>
<p><code><br />
{<br />
    "payload": '{"key1":"value1", "key2":"value2", "key3":"value3", "mytime":"1480195100", "mytag":"azurefunctions.msg"}'<br />
}<br />
</code></p>
<p>If events are sent to the function successfully, a HTTP trigger function handles the events and the following logs can be seen in Azure Functions log stream: </p>
<p><code><br />
2016-11-26T21:18:55.200 Function started (Id=5392e7ae-3b8e-4f65-9fc1-6ae529cdfe3a)<br />
2016-11-26T21:18:55.200 C# HTTP trigger function to process fluentd output request.<br />
2016-11-26T21:18:55.200 key1=value1<br />
2016-11-26T21:18:55.200 key2=value2<br />
2016-11-26T21:18:55.200 key3=value3<br />
2016-11-26T21:18:55.200 mytime=1480195100<br />
2016-11-26T21:18:55.200 mytag=azurefunctions.msg<br />
2016-11-26T21:18:55.200 Function completed (Success, Id=5392e7ae-3b8e-4f65-9fc1-6ae529cdfe3a)<br />
</code></p>
<h2>Advanced Senarios</h2>
<h3>1. Near Real-time processing</h3>
<p>Function Apps can output messages to different means or data stores. For example, fluentd collects events generated from IoT devices and send them to Azure Function, and the the HTTP trigger function transforms the events and processes the data to store in a persistent storage or to pass them to different means. Here are some of options available at the time of writing: </p>
<ul style="list-style:disc inside">
<li><a href="https://github.com/Azure/azure-webjobs-sdk-extensions">Store JSON documents on DocumentDB</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-event-hubs">Send events to Event Hub</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-service-bus">Send messages to Azure Service Bus Queues</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-queue">Send messages to Azure Storage Queues</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-blob">Store blobs to Azure Blob Storage</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-notification-hubs">Push notifications to Notification Hub</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-twilio"><a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-twilio">Send SMS text messages via Twilio</a></a></li>
<li><a href="https://sendgrid.com/">Send emails via SendGrid</a></li>
</ul>
<h3>2. Background jobs processing</h3>
<p>If the jobs are expected to be large long running ones, it's recommended that you refactor them into smaller function sets that work together and return fast responses. For example, you can pass the HTTP trigger payload into a queue to be processed by a queue trigger function. Or if the payload is too big to pass into the queue, you can store them onto Azure Blob storage at first, then pass only limited amount of the data into a queue just to trigger background workers to process the actual work. These approaches allow you to do the actual work asynchronously and return an immediate response. </p>
<h2>LINKS</h2>
<ul style="list-style:disc inside">
<li><a href="https://github.com/yokawasa/fluent-plugin-azurefunctions">fluent-plugin-azurefunctions</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-overview">Azure Functions Overview</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings">Azure functions Triggers and Bindings</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-best-practices">Azure Functions Best Practices</a></li>
</ul>
<p>END</p>
