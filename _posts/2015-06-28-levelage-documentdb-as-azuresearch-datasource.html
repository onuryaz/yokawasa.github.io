---
layout: post
status: publish
published: true
title: DocumentDBをAzure Searchのデータソースとして利用する
author:
  display_name: Yoichi Kawasaki
  login: yoichi
  email: yokawasa@gmail.com
  url: http://github.com/yokawasa
author_login: yoichi
author_email: yokawasa@gmail.com
author_url: http://github.com/yokawasa
wordpress_id: 34
wordpress_url: http://unofficialism.info/posts/?p=34
date: '2015-06-28 16:13:45 +0900'
date_gmt: '2015-06-28 07:13:45 +0900'
categories:
- Azure
tags:
- AzureSearch
- DocumentDB
- Crawler
---
<p>Azure Searchのインデックス更新方法には大きく分けてPUSHとPULLの２種類ある。PUSHは直接Indexing APIを使ってAzure SearchにコンテンツをPOSTして更新。PULLは特定データソースに対してポーリングして更新で、Azure Searchの場合、DocumentDBとSQL Databaseの2種類のデータソースを対象にワンタイムもしくは定期的なスケジュール実行が可能となっている。ここではDocumentDBをデータソースとしてインデックスを更新する方法を紹介する。</p>
<h2>サンプル構成と処理フローの説明</h2>
<p>データソースにDocumentDBを利用する。データ「<a href="http://unofficialism.info/posts/crawler-with-documentdb-python-sdk-and-feedparser/" target="_blank">DOCUMENTDB PYTHON SDKとFEEDPARSERで作る簡易クローラー</a>」においてクローリングされDocumentDBに保存されたブログ記事データを使用する。そしてDocumentDBを定期的にポーリングを行い更新があったレコードのみをAzure Searchインデックスに反映するためにDocumentDBインデクサーを設定する。全体構成としては下記の通りとなる。</p>
<p><center><br />
<img src="https://farm1.staticflickr.com/421/19163174486_c26a523730_c.jpg" width="800" height="348" alt="documentdb-indexer"><br />
</center></p>
<h2>DocumentDBと更新先検索インデックスのフィールドのマッピング</h2>
<p>DocumentDBをデータソースとしてAzure Searchインデックスに更新を行うためDocumentDBの参照先コレクションのフィールドと更新先Azure Searchインデックスのフィールドをマッピングを行う。マッピングはデータソース定義中のDocumentDB参照用Queryで行う。Azure SearchインデックスにインジェストするフィールドをDocumentDBのSELECTクエリー指定するのだが、Azure SearchとDocumentDBのフィールドが異なる場合は下図のようにSELECT "Docdbフィールド名" AS "Searchフィールド名"でインジェスト先フィールド名を指定する。データソース定義については後述の設定内容を確認ください。</p>
<p><center><br />
<img src="https://c1.staticflickr.com/1/376/19036611840_5486c2e1f8_z.jpg" width="640" height="215" alt="documentdb-azuresearch-mapping"><br />
</center></p>
<h2>Configuration</h2>
<p>以下１～４のステップでデータソースの作成、検索インデックスの作成、インデクサーの作成、インデクサーの実行を行う。</p>
<ol>
<li>データソースの作成</li>
<p>credential.connectionStringで接続先DocumentDB文字列と対象データベースの指定を行う。container.(name|query)で対象コレクション名と参照用SELECT文を指定する。SELECT文はDocumentDBとインジェスト先Azure Searchのフィールドセット（フィールド名と数）が同じであれば省略可。詳細は<a href="https://azure.microsoft.com/ja-jp/documentation/articles/documentdb-search-indexer/#CreateDataSource" target="_blank">こちら</a>を参照。<br />
<script src="https://gist.github.com/yokawasa/408692be76e30f9a96ac.js"></script></p>
<li>インデックスの作成</li>
<p>下記のスキーマでAzure Searchインデックスを作成する。<br />
<code lang="javascript"><br />
{<br />
    "name": "articles-test",<br />
    "fields": [<br />
        { "name":"itemno", "type":"Edm.String", "key": true, "searchable": false },<br />
        { "name":"subject", "type":"Edm.String", "filterable":false, "sortable":false, "facetable":false},<br />
        { "name":"body", "type":"Edm.String","filterable":false,"sortable":false, "facetable":false, "analyzer":"ja.lucene"},<br />
        { "name":"url", "type":"Edm.String", "sortable":false, "facetable":false },<br />
        { "name":"date", "type":"Edm.DateTimeOffset", "facetable":false}<br />
     ]<br />
}<br />
</code></p>
<li>DocumentDBインデクサーの作成</li>
<p>DocumentDBインデクサー作成のための設定。DatSourceNameとtargetIndexNameにそれぞれ1で作成したデータソース名とインジェスト先のインデックス名を指定する。スケジュール実行させたい場合は下記の通りscheduleを設定する。ここではintervalをPT5Mとしているがこれは5分毎実行を意味する。詳しくは<a href="https://azure.microsoft.com/ja-jp/documentation/articles/documentdb-search-indexer/#CreateIndexer" target="_blank">こちら</a>を参照。<br />
<script src="https://gist.github.com/yokawasa/21ea5e8400fbec52b36d.js"></script></p>
<li>インデクサーの明示的に実行</li>
<p>スケジュール実行ではなくインデクサーをすぐに実行したい場合は下記のフォーマットでPOSTリクエストを送信する。<br />
<code><br />
POST https://[Search service name].search.windows.net/indexers/[indexer name]/run?api-version=[api-version]<br />
api-key: [Search service admin key]<br />
</code>
</ol>
<h2>実行結果確認方法</h2>
<p><center><br />
<img src="https://c4.staticflickr.com/4/3693/19198973716_feb1f94aff_z.jpg" width="640" height="388" alt="AzureSearchIndexerStatus"><br />
</center><br />
上記イメージの通りAzureポータル(preview)よりAzure Search &rarr; indexersタイルをたどることでインデクサーの実行結果や過去の履歴を確認することができる。ただし、ここではAPI経由で取得する方法を紹介する。<br />
下記フォーマットでGETリクエストすることでインデクサーの現在の稼働状態と実行履歴を取得することができる。実行履歴は最後の実行結果だけではなく最近完了した50件の実行内容が含まれる。<br />
<code><br />
GET https://[Search service name].search.windows.net/indexers/[indexer name]/status?api-version=[api-version]<br />
api-key: [Search service admin key]<br />
</code></p>
<p>以下実行結果。executionHistoryが履歴、lastResultが最後の実行結果、statusが現在のインデクサーのステータスとなっている。<br />
<code lang="javascript"><br />
{<br />
    "@odata.context": "https://yoichidemo.search.windows.net/$metadata#Microsoft.Azure.Search.V2015_02_28_Preview.IndexerExecutionInfo",<br />
    "executionHistory": [<br />
        {<br />
            "endTime": "2015-06-25T05:55:01.393Z",<br />
            "errorMessage": "Data source 'docdbds-article' does not exist",<br />
            "errors": [],<br />
            "finalTrackingState": null,<br />
            "initialTrackingState": null,<br />
            "itemsFailed": 0,<br />
            "itemsProcessed": 0,<br />
            "startTime": "2015-06-25T05:55:01.393Z",<br />
            "status": "transientFailure"<br />
        },<br />
        ...(omit)...<br />
        {<br />
            "endTime": "2015-06-25T02:15:02.155Z",<br />
            "errorMessage": null,<br />
            "errors": [],<br />
            "finalTrackingState": "1434871500",<br />
            "initialTrackingState": "1434871500",<br />
            "itemsFailed": 0,<br />
            "itemsProcessed": 0,<br />
            "startTime": "2015-06-25T02:15:01.452Z",<br />
            "status": "success"<br />
        },<br />
        {<br />
            "endTime": "2015-06-25T02:10:01.144Z",<br />
            "errorMessage": null,<br />
            "errors": [],<br />
            "finalTrackingState": "1434871500",<br />
            "initialTrackingState": "1434871500",<br />
            "itemsFailed": 0,<br />
            "itemsProcessed": 0,<br />
            "startTime": "2015-06-25T02:10:00.022Z",<br />
            "status": "success"<br />
        }<br />
    ],<br />
    "lastResult": {<br />
        "endTime": "2015-06-25T05:59:02.016Z",<br />
        "errorMessage": "Data source 'docdbds-article' does not exist",<br />
        "errors": [],<br />
        "finalTrackingState": null,<br />
        "initialTrackingState": null,<br />
        "itemsFailed": 0,<br />
        "itemsProcessed": 0,<br />
        "startTime": "2015-06-25T05:59:02.016Z",<br />
        "status": "transientFailure"<br />
    },<br />
    "name": "docdbindexer",<br />
    "status": "running"<br />
}<br />
</code></p>
<h2>Content DBの有効性について</h2>
<p>ここではAzure SearchのfeedingソリューションとしてDocumentDBを使用したPULLインデックス更新方法を紹介した。このようにクローリングされたデータを直接Azure SearchのIndex APIを使ってインデックスを更新するのではなく、今回のDocumentDBのように所謂Content DBに格納してからそれを元にインデックスを更新するのにはいくつか意味がある。例えば、インデックス構造を変更したい場合、再フィードが必要になるがContent DBがあれば再度クローリングする必要がない。通常クローリング（特にフルクローリング）のコストは大きい。また、Content DBがあれば別アカウント、リージョンにインデックスのレプリカの構築、他に、同一のデータを使って別構造のインデックを構築するといったことも容易に可能になる。<br />
さらに、現時点でAzure Searchがデータ加工のためのパイプラインの仕組み（Lucene/Solr, ElasticSearchでいうところのカスタムAnalyzer）がないことから、インデックスに放り込む前の一時データ加工用のデータベースとしても有効であると考えている。</p>
<h2>LINKS</h2>
<ul style="list-style:disc inside">
<li><a href="https://azure.microsoft.com/ja-jp/documentation/articles/documentdb-search-indexer/" target="_blank">インデクサーを使用した DocumentDB と Azure Search の接続</a></li>
</ul>
